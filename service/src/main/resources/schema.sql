CREATE TABLE IF NOT EXISTS users
(
    id    BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    email VARCHAR(254) NOT NULL UNIQUE,
    name  VARCHAR(250) NOT NULL
);

CREATE TABLE IF NOT EXISTS categories
(
    id   BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    name VARCHAR(50) NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS locations
(
    id  BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    lat FLOAT NOT NULL,
    lon FLOAT NOT NULL,
    CONSTRAINT unique_location UNIQUE (lat, lon)
);

CREATE TABLE IF NOT EXISTS events
(
    id                 BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    annotation         VARCHAR(2000)               NOT NULL,
    category_id        BIGINT REFERENCES categories (id) ON DELETE CASCADE,
    confirmed_requests INT                                  DEFAULT 0,
    created_on         TIMESTAMP WITHOUT TIME ZONE NOT NULL,
    description        VARCHAR(7000)               NOT NULL,
    event_date         TIMESTAMP WITHOUT TIME ZONE NOT NULL,
    initiator_id       BIGINT REFERENCES users (id) ON DELETE CASCADE,
    location_id        BIGINT REFERENCES locations (id) ON DELETE CASCADE,
    paid               BOOLEAN                     NOT NULL DEFAULT FALSE,
    participant_limit  INT                                  DEFAULT 0,
    published_on       TIMESTAMP WITHOUT TIME ZONE,
    request_moderation BOOLEAN                     NOT NULL DEFAULT TRUE,
    state              VARCHAR(20)                 NOT NULL CHECK (state IN ('PENDING', 'PUBLISHED', 'CANCELED')),
    title              VARCHAR(120)                NOT NULL
);

CREATE TABLE IF NOT EXISTS compilations
(
    id     BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    pinned BOOLEAN     NOT NULL DEFAULT FALSE,
    title  VARCHAR(50) NOT NULL UNIQUE
);

CREATE TABLE IF NOT EXISTS compilation_events
(
    compilation_id BIGINT REFERENCES compilations (id) ON DELETE CASCADE,
    event_id       BIGINT REFERENCES events (id) ON DELETE CASCADE,
    PRIMARY KEY (compilation_id, event_id)
);

CREATE TABLE IF NOT EXISTS requests
(
    id           BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    created      TIMESTAMP WITHOUT TIME ZONE NOT NULL,
    event_id     BIGINT REFERENCES events (id) ON DELETE CASCADE,
    requester_id BIGINT REFERENCES users (id) ON DELETE CASCADE,
    status       VARCHAR(20)                 NOT NULL CHECK (status IN ('PENDING', 'CONFIRMED', 'REJECTED', 'CANCELED')),
    CONSTRAINT unique_request UNIQUE (event_id, requester_id)
);

CREATE TABLE IF NOT EXISTS event_views
(
    id         BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    event_id   BIGINT REFERENCES events (id) ON DELETE CASCADE,
    ip_address VARCHAR(45) NOT NULL,
    CONSTRAINT unique_views UNIQUE (event_id, ip_address)
);

CREATE TABLE IF NOT EXISTS event_comments
(
    id           BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    event_id     BIGINT REFERENCES events (id) ON DELETE CASCADE,
    commenter_id BIGINT REFERENCES users (id) ON DELETE CASCADE,
    commenter_ip varchar(40),
    content      TEXT NOT NULL,
    created_at   TIMESTAMP DEFAULT NOW(),
    updated_at   TIMESTAMP,
    parent_id    BIGINT,
    has_replies  BOOLEAN   DEFAULT FALSE,
    is_deleted   BOOLEAN   default FALSE,
    FOREIGN KEY (parent_id) REFERENCES event_comments (id)
);

CREATE TABLE IF NOT EXISTS report_reasons
(
    id BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    code VARCHAR(200) NOT NULL UNIQUE,
    description varchar(1000) NOT NULL
);

CREATE TABLE IF NOT EXISTS comment_reports
(
    id           SERIAL PRIMARY KEY,
    comment_id   BIGINT       NOT NULL REFERENCES event_comments (id) ON DELETE CASCADE,
    user_id      BIGINT       NOT NULL REFERENCES users (id) ON DELETE CASCADE,
    reason       BIGINT NOT NULL REFERENCES report_reasons(id) ON DELETE RESTRICT,
    status       VARCHAR(20)  NOT NULL DEFAULT 'PENDING' CHECK (status IN ('PENDING', 'IN_WORK', 'REVIEWING', 'RESOLVED', 'REJECTED')),
    description  VARCHAR(500),
    moderator_id BIGINT       REFERENCES users (id) ON DELETE SET NULL,
    created_at   TIMESTAMP             DEFAULT NOW(),
    resolved_at  TIMESTAMP,
    notes        VARCHAR(50000),
    UNIQUE (user_id, comment_id)
);

CREATE INDEX IF NOT EXISTS idx_event_category_date ON events (category_id, event_date);

CREATE INDEX IF NOT EXISTS idx_compilation_pinned ON compilations (pinned);

CREATE INDEX IF NOT EXISTS idx_event_views_event_id ON event_views (event_id);

CREATE INDEX IF NOT EXISTS idx_event_views_ip ON event_views (ip_address);

CREATE INDEX IF NOT EXISTS idx_comments_parent_id ON event_comments (parent_id);

CREATE OR REPLACE FUNCTION update_has_replies()
    RETURNS TRIGGER AS
'
    BEGIN
        IF TG_OP = ''INSERT'' THEN
            IF NEW.parent_id IS NOT NULL THEN
                UPDATE event_comments
                SET has_replies = TRUE
                WHERE id = NEW.parent_id
                  AND NOT has_replies;
            END IF;
            RETURN NEW;

        ELSIF TG_OP = ''DELETE'' THEN
            IF OLD.parent_id IS NOT NULL THEN
                UPDATE event_comments
                SET has_replies = EXISTS (SELECT 1
                                          FROM event_comments ec
                                          WHERE ec.parent_id = OLD.parent_id
                                            AND ec.id <> OLD.id)
                WHERE id = OLD.parent_id;
            END IF;
            RETURN OLD;
        END IF;
    END;
' LANGUAGE plpgsql;

CREATE OR REPLACE TRIGGER trigger_update_has_replies
    AFTER INSERT OR DELETE
    ON event_comments
    FOR EACH ROW
EXECUTE FUNCTION update_has_replies();

-- 1. Функция для рекурсивного обновления is_deleted у потомков
CREATE OR REPLACE FUNCTION mark_children_as_deleted()
    RETURNS TRIGGER AS
'
    BEGIN
        -- Проверяем, что комментарий только что был помечен как удаленный
        IF NEW.is_deleted = TRUE AND OLD.is_deleted = FALSE THEN
            -- Рекурсивно находим всех потомков и помечаем их как удаленные
            WITH RECURSIVE descendants AS (SELECT id
                                           FROM event_comments
                                           WHERE parent_id = NEW.id
                                           UNION ALL
                                           SELECT ec.id
                                           FROM event_comments ec
                                                    INNER JOIN descendants d ON ec.parent_id = d.id)
            UPDATE event_comments
            SET is_deleted = TRUE
            WHERE id IN (SELECT id FROM descendants);
        END IF;
        RETURN NEW;
    END;
' LANGUAGE plpgsql;

-- 2. Триггер, срабатывающий после обновления комментария
CREATE OR REPLACE TRIGGER trigger_mark_children_deleted
    AFTER UPDATE
    ON event_comments
    FOR EACH ROW
EXECUTE FUNCTION mark_children_as_deleted();